"""
Unit tests for rococo/models/non_versioned_model.py
"""
import unittest
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
from uuid import UUID, uuid4

from rococo.models.non_versioned_model import (
    NonVersionedModel,
    default_datetime,
    get_uuid_hex
)


class TestDefaultDatetime(unittest.TestCase):
    """Tests for default_datetime function."""

    def test_returns_datetime(self):
        """Test that default_datetime returns a datetime object."""
        result = default_datetime()
        self.assertIsInstance(result, datetime)

    def test_returns_utc_datetime(self):
        """Test that default_datetime returns UTC timezone."""
        result = default_datetime()
        self.assertEqual(result.tzinfo, timezone.utc)

    def test_returns_current_time(self):
        """Test that default_datetime returns approximately current time."""
        before = datetime.now(timezone.utc)
        result = default_datetime()
        after = datetime.now(timezone.utc)
        
        self.assertGreaterEqual(result, before)
        self.assertLessEqual(result, after)


class TestGetUuidHex(unittest.TestCase):
    """Tests for get_uuid_hex function."""

    def test_returns_hex_string(self):
        """Test that get_uuid_hex returns a hex string."""
        result = get_uuid_hex()
        self.assertIsInstance(result, str)
        self.assertEqual(len(result), 32)  # UUID hex is 32 characters
        # Verify it's a valid hex string
        int(result, 16)

    def test_unique_values(self):
        """Test that get_uuid_hex returns unique values."""
        uuid1 = get_uuid_hex()
        uuid2 = get_uuid_hex()
        self.assertNotEqual(uuid1, uuid2)

    def test_with_int_zero(self):
        """Test get_uuid_hex with int=0."""
        result = get_uuid_hex(0)
        expected = UUID(int=0, version=4).hex
        self.assertEqual(result, expected)

    def test_with_int_value(self):
        """Test get_uuid_hex with a specific int value."""
        result = get_uuid_hex(12345)
        expected = UUID(int=12345, version=4).hex
        self.assertEqual(result, expected)


@dataclass
class SimpleNonVersionedModel(NonVersionedModel):
    """Simple test model for non-versioned model tests."""
    name: Optional[str] = None
    age: Optional[int] = None


@dataclass
class NestedDataclass:
    """A simple dataclass for testing nested objects."""
    value: str = ""
    
    def as_dict(self, convert_datetime_to_iso_string=False, convert_uuids=True):
        return {"value": self.value}


@dataclass
class ModelWithNestedDataclass(NonVersionedModel):
    """Model with a nested dataclass field."""
    nested: Optional[NestedDataclass] = None


@dataclass
class ModelWithUuidList(NonVersionedModel):
    """Model with a list of UUIDs."""
    uuid_list: Optional[List[UUID]] = None


@dataclass
class ModelWithDataclassList(NonVersionedModel):
    """Model with a list of dataclasses."""
    items: Optional[List[NestedDataclass]] = None


@dataclass
class ModelWithSensitiveData(NonVersionedModel):
    """Model with sensitive fields that should be excluded from API."""
    username: Optional[str] = None
    password_hash: Optional[str] = None
    raw_password: Optional[str] = None
    refresh_token_jti: Optional[str] = None


class TestNonVersionedModelBasics(unittest.TestCase):
    """Tests for basic NonVersionedModel functionality."""

    def test_default_entity_id(self):
        """Test that entity_id is generated by default."""
        model = SimpleNonVersionedModel()
        self.assertIsNotNone(model.entity_id)
        self.assertEqual(len(model.entity_id), 32)

    def test_custom_entity_id(self):
        """Test that custom entity_id can be set."""
        custom_id = "custom123456789012345678901234"
        model = SimpleNonVersionedModel(entity_id=custom_id)
        self.assertEqual(model.entity_id, custom_id)

    def test_post_init(self):
        """Test __post_init__ executes without error."""
        model = SimpleNonVersionedModel(name="Test")
        # No assertions needed - just verify no errors

    def test_repr(self):
        """Test __repr__ returns correct format."""
        model = SimpleNonVersionedModel()
        repr_str = repr(model)
        
        self.assertIn("SimpleNonVersionedModel", repr_str)
        self.assertIn("entity_id=", repr_str)
        self.assertIn(model.entity_id, repr_str)


class TestNonVersionedModelAsDict(unittest.TestCase):
    """Tests for NonVersionedModel.as_dict method."""

    def test_as_dict_basic(self):
        """Test basic as_dict conversion."""
        model = SimpleNonVersionedModel(name="John", age=30)
        result = model.as_dict()
        
        self.assertEqual(result['name'], "John")
        self.assertEqual(result['age'], 30)
        self.assertEqual(result['entity_id'], model.entity_id)

    def test_as_dict_with_datetime_conversion(self):
        """Test as_dict with datetime conversion."""
        @dataclass
        class ModelWithDatetime(NonVersionedModel):
            created_at: Optional[datetime] = None
        
        dt = datetime(2023, 6, 15, 12, 30, 0, tzinfo=timezone.utc)
        model = ModelWithDatetime(created_at=dt)
        
        result = model.as_dict(convert_datetime_to_iso_string=True)
        self.assertEqual(result['created_at'], dt.isoformat())
        
        result_no_convert = model.as_dict(convert_datetime_to_iso_string=False)
        self.assertEqual(result_no_convert['created_at'], dt)

    def test_as_dict_with_uuid_conversion(self):
        """Test as_dict with UUID conversion."""
        @dataclass
        class ModelWithUuid(NonVersionedModel):
            ref_id: Optional[UUID] = None
        
        uuid_val = uuid4()
        model = ModelWithUuid(ref_id=uuid_val)
        
        result = model.as_dict(convert_uuids=True)
        self.assertEqual(result['ref_id'], str(uuid_val))
        
        result_no_convert = model.as_dict(convert_uuids=False)
        self.assertEqual(result_no_convert['ref_id'], uuid_val)

    def test_as_dict_with_nested_dataclass(self):
        """Test as_dict with nested dataclass."""
        nested = NestedDataclass(value="test_value")
        model = ModelWithNestedDataclass(nested=nested)
        
        result = model.as_dict()
        self.assertEqual(result['nested'], {"value": "test_value"})

    def test_as_dict_with_uuid_list(self):
        """Test as_dict with list of UUIDs."""
        uuid1 = uuid4()
        uuid2 = uuid4()
        model = ModelWithUuidList(uuid_list=[uuid1, uuid2])
        
        result = model.as_dict(convert_uuids=True)
        self.assertEqual(result['uuid_list'], [str(uuid1), str(uuid2)])
        
        result_no_convert = model.as_dict(convert_uuids=False)
        self.assertEqual(result_no_convert['uuid_list'], [uuid1, uuid2])

    def test_as_dict_with_dataclass_list(self):
        """Test as_dict with list of dataclasses."""
        item1 = NestedDataclass(value="item1")
        item2 = NestedDataclass(value="item2")
        model = ModelWithDataclassList(items=[item1, item2])
        
        result = model.as_dict()
        self.assertEqual(result['items'], [{"value": "item1"}, {"value": "item2"}])

    def test_as_dict_with_regular_list(self):
        """Test as_dict with regular list (not UUIDs or dataclasses)."""
        @dataclass
        class ModelWithStringList(NonVersionedModel):
            tags: Optional[List[str]] = None
        
        model = ModelWithStringList(tags=["tag1", "tag2", "tag3"])
        
        result = model.as_dict()
        self.assertEqual(result['tags'], ["tag1", "tag2", "tag3"])

    def test_as_dict_with_empty_list(self):
        """Test as_dict with empty lists."""
        model = ModelWithUuidList(uuid_list=[])
        result = model.as_dict()
        self.assertEqual(result['uuid_list'], [])


class TestNonVersionedModelGetForDb(unittest.TestCase):
    """Tests for NonVersionedModel.get_for_db method."""

    def test_get_for_db_returns_dict(self):
        """Test get_for_db returns a dictionary."""
        model = SimpleNonVersionedModel(name="Test", age=25)
        result = model.get_for_db()
        
        self.assertIsInstance(result, dict)
        self.assertEqual(result['name'], "Test")
        self.assertEqual(result['age'], 25)
        self.assertIn('entity_id', result)


class TestNonVersionedModelGetForApi(unittest.TestCase):
    """Tests for NonVersionedModel.get_for_api method."""

    def test_get_for_api_excludes_sensitive_fields(self):
        """Test get_for_api excludes password_hash, raw_password, refresh_token_jti."""
        model = ModelWithSensitiveData(
            username="john",
            password_hash="hashed_password",
            raw_password="secret123",
            refresh_token_jti="token_jti_value"
        )
        
        result = model.get_for_api()
        
        self.assertEqual(result['username'], "john")
        self.assertNotIn('password_hash', result)
        self.assertNotIn('raw_password', result)
        self.assertNotIn('refresh_token_jti', result)

    def test_get_for_api_includes_entity_id(self):
        """Test get_for_api includes entity_id."""
        model = SimpleNonVersionedModel(name="Test")
        result = model.get_for_api()
        
        self.assertIn('entity_id', result)


class TestNonVersionedModelValidate(unittest.TestCase):
    """Tests for NonVersionedModel.validate method."""

    def test_validate_does_nothing(self):
        """Test validate method is a no-op."""
        model = SimpleNonVersionedModel(name="Test")
        # Should not raise any exception
        model.validate()


class TestNonVersionedModelPrepareForSave(unittest.TestCase):
    """Tests for NonVersionedModel.prepare_for_save method."""

    def test_prepare_for_save_calls_validate(self):
        """Test prepare_for_save calls validate."""
        model = SimpleNonVersionedModel(name="Test")
        
        # Should not raise any exception
        model.prepare_for_save()

    def test_prepare_for_save_with_changed_by_id(self):
        """Test prepare_for_save with changed_by_id parameter."""
        model = SimpleNonVersionedModel(name="Test")
        user_id = uuid4()
        
        # Should not raise any exception
        model.prepare_for_save(_changed_by_id=user_id)


class TestNonVersionedModelEdgeCases(unittest.TestCase):
    """Tests for edge cases in NonVersionedModel."""

    def test_model_with_none_values(self):
        """Test model with None values."""
        model = SimpleNonVersionedModel(name=None, age=None)
        result = model.as_dict()
        
        self.assertIsNone(result['name'])
        self.assertIsNone(result['age'])

    def test_model_with_mixed_list(self):
        """Test model with mixed type list (should pass through unchanged)."""
        @dataclass
        class ModelWithMixedList(NonVersionedModel):
            items: Optional[List[Any]] = None
        
        model = ModelWithMixedList(items=["string", 123, True])
        result = model.as_dict()
        
        self.assertEqual(result['items'], ["string", 123, True])


if __name__ == '__main__':
    unittest.main()
